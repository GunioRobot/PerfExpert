CSS: style.css

PerfExpert Reference
====================

This document explains features of PerfExpert in detail. For an easy introduction to PerfExpert and what it looks like, please see the [Quick Start Guide](http://www.tacc.utexas.edu/perfexpert/quick-start-guide/). For information on the PerfExpert output, see [PerfExpert metrics](http://www.tacc.utexas.edu/perfexpert/metrics).

Profiling using PerfExpert has two stages: 

1. Running your program with a special application, `perfexpert_run_exp`, to collect performance-related information about your program
2. Running `perfexpert` on the file generated by `perfexpert_run_exp`

perfexpert\_run\_exp
--------------------

`perfexpert_run_exp` is a shell script that runs your program multiple times (typically 5-6 times), during which, it will measure different performance-related metrics. The syntax for its invocation is:

    $ perfexpert_run_exp 

    Usage: perfexpert_run_exp [OPTION...] program-name [arguments]
    Program to gather measurements for use with PerfExpert
    
      -s, --structure FILE		Use FILE as program structure (generated by hpcstruct)
      -o, --output FILE.xml		Save measurements to FILE.xml
      -n, --no-debug		Do not switch to debug mode if program fails to execute with PerfExpert

Hence, if your application is called `hello-world` which takes in a name as an input parameter, you would run it with PerfExpert as:

    $ perfexpert_run_exp ./hello-world John

**Note to users of [TACC](http://www.tacc.utexas.edu/) machines**: The `perfexpert_run_exp` command internally uses `ibrun`. Hence, even if `hello-world` was an MPI application, you would still invoke it in the same manner as shown above.

At the end of the execution, the above command would generate a file: `experiment-${JOB_NAME}.o${JOB_ID}.xml` (or just `experiment.xml` if the command was ran outside of a batch submission system). This file contains the recorded performance information for your application.

### Working with shell scripts / complicated program invocations
If your program invocation involves using shell redirects ('`<`' or '`>`' for setting the standard input or standard output), you need to place the command into a shell script. Also, in such cases, the `--structure` option needs to be used with `perfexpert_run_exp`. This is required so that PerfExpert (and in turn, the underlying software - HPCToolkit) can learn about the functions and loops in the application being profiled. The value passed with `--structure` is the name of the file generated after running `${PERFEXPERT_HPCTOOLKIT_HOME}/bin/hpcstruct` on your application (`<application>.hpcstruct`). For instance, if your application (binary) is called `hello-world` and if you decide to place it into a shell script `run-hello-world.sh`, which reads:

    $ cat run-hello-world.sh

    echo John | ./hello-world

Then you would use the following commands to run your application with PerfExpert:

    $ ${PERFEXPERT_HPCTOOLKIT_HOME}/bin/hpcstruct hello-world    # This generates hello-world.hpcstruct
    
    $ perfexpert_run_exp --structure hello-world.hpcstruct ./run-hello-world.sh

Another note of importance is that the shell script must not use the `#!` line for specifying the interpreter, i.e. the first line in the `run-hello-world.sh` should not invoke the shell. This limits user shell scripts (that are passed to `perfexpert_run_exp`) to those using the Bourne shell syntax. We are working to find a way around this limitation.

### Error reports
If the application or command passed to `perfexpert_run_exp` fails to run successfully, PerfExpert switches to debug mode to collect details about the failure. The following details are collected and saved to the `perfexpert_debug.out` file:

1. Output of `uname -a` (Operating System version details)
2. Contents of `/proc/cpuinfo` (Details of processor)
3. The command that failed to run correctly
4. Stack trace for the failed command
5. Debug information from HPCToolkit

We request that you send this file to us to enable us to correct the behavior of PerfExpert.

The failed execution of any command is detected by means of the return code. If the return code is non-zero, `perfexpert_run_exp` starts collecting the debug information. If your application does not explicitly return an error code, this may cause `perfexpert_run_exp` to mistakenly think that the command failed. To disable switching to debug mode, use the `--no-debug` or `-n` option to `perfexpert_run_exp`, e.g.:

    $ perfexpert_run_exp --no-debug ./command-with-non-zero-exit-code

perfexpert
----------

Once the performance metrics have been collected for your application using `perfexpert_run_exp`, the measurements are analyzed using `perfexpert`.

    $ perfexpert
    
    USAGE: perfexpert [-h|--help] [-a|--aggregate] [(-t|--threads) <threads>] <threshold> <experiment.xml> [<experiment.xml>]
    
      [-h|--help]
            Show this help screen
    
      [-a|--aggregate]
            Show whole-program information only, no function- or loop-level
            information
    
      [(-t|--threads) <threads>]
    
      <threshold>
            Threshold between 0 and 1
    
      <experiment.xml>
            experiment.xml file generated using `perfexpert_run_exp`
    
      [<experiment.xml>]
            second experiment.xml file, for comparison only

Generally, the command would be executed as:

    $ perfexpert 0.1 experiment.xml

The `0.1` refers to the threshold, meaning that we are interested in functions and loops that take at least 10% of the total running time. The `experiment.xml` is the result of running `perfexpert_run_exp` on your application. This will display the PerfExpert metrics, which are explained in detail [here](http://www.tacc.utexas.edu/perfexpert/metrics).

It is also possible to compare two runs (say naive and optimized executions of the same code) by passing the corresponding `experiment.xml` files to `perfexpert`:

    $ perfexpert 0.1 experiment-naive.xml experiment-optimized.xml

Often, you might be interested in getting an overview of the program performance instead of getting details of each code segment. To get the aggregate (program-wide) performance information, use the `--aggregate` or `-a` option to `perfexpert`. In this case, the threshold argument is not interpreted but is still required.

### Thread-specific metrics
By default, PerfExpert combines performance metrics from all threads. It might be useful to look at performance information for specific threads (or to combine performance information of certain threads). This can be done using the `--threads` or `-t` option. There are various ways to identify the threads whose information should be displayed:

* Using the thread IDs: `--threads 0` for information specific to thread #0
* Listing multiple thread IDs: `--threads 1,3,5,7`
* Using bounded range: `--threads 1-4` for metrics for threads 1, 2, 3 and 4
* Using unbounded range: `--threads 1-` for all threads other than thread #0

The displayed output for all of the above combinations follows the same semantics, as described in <http://wwww.tacc.utexas.edu/perfexpert/metrics> but the values refer to the specific selected threads.

autoscope
---------

PerfExpert comes bundled with AutoSCOPE, a tool that can recommend optimizations to your code based on the PerfExpert output. This tool is used by piping the output of `perfexpert` to `autoscope` or by passing in the text file containing the PerfExpert output to `autoscope`.

    $ autoscope --help
    
    AutoSCOPE v1.0
    Copyright (C) 2011 Texas State University
    http://www.cs.txstate.edu/~burtscher/research/PerfExpert/AutoSCOPE/
    
    USAGE: autoscope [-h|--help] [--disable-flags] [--disable-examples] [<perfexpert.out>]
    
      [-h|--help]
            Show this help screen
    
      [--disable-flags]
            Do not show compiler flags in suggestions
    
      [--disable-examples]
            Do not show code examples in suggestions
    
      [<perfexpert.out>]
            PerfExpert output file

A sample execution of AutoSCOPE with PerfExpert is shown below:

    $ perfexpert 0.1 experiment-galois.xml | autoscope 
    
    AutoSCOPE v1.0
    Copyright (C) 2011 Texas State University
    http://www.cs.txstate.edu/~burtscher/research/PerfExpert/AutoSCOPE/
    
    Function GaloisRuntime::ForEachWork::GraphNode, 1024, true>, process>::operator()() (31% of the total runtime)
    ===============================================================================
    * use trace scheduling to reduce the branch taken frequency
      - example: if (likely_condition) f(); else g(); h(); -> void s() {g(); h();} ... if (!likely_condition) {s();} f(); h();
    
    * factor out common code into subroutines
      - example: ... same_code ... same_code ... -> void f() {same_code;} ... f() ... f() ...;
    
    * allow inlining only for subroutines with one call site or very short bodies
      - compiler flag: use the "-nolib-inline", "-fno-inline", "-fno-inline-functions", or "-finline-limit=n" (with a small 'n') compiler flags

* * *
